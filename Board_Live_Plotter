import sys, math, random, queue, threading, time
import pyautogui
import serial
import xlrd
import numpy as np
from PyQt5.QtWidgets import QApplication, QWidget, QShortcut
from PyQt5.QtGui import QPainter, QPen, QColor, QKeySequence, QMouseEvent
from PyQt5.QtCore import Qt, QTimer, QThread
from scipy import zeros, signal, random, fft, arange
import matplotlib.pyplot as plt
from numpy import sin, linspace, pi
from pylab import plot, show, title, xlabel, ylabel, subplot
from pynput import keyboard


global state
def on_press(key):
	if(format(key) == "Key.space"):
		print("reset")
		global state
		state = 0
	# try:
	#     print('alphanumeric key {0} pressed'.format(
	#         key.char))
	# except AttributeError:
	#     print('special key {0} pressed'.format(
	#         key))

listener = keyboard.Listener(
    on_press=on_press)
listener.start()



timenow = 0
lasttime = 0
hz = 0

ser = serial.Serial('COM5',timeout=5)

ser.baudrate = 57600	
#ser.timeout = 0            # non blocking read	
data = [0,0,0,0,0,0,0,0]
datamem = np.array([[0 for x in range(8)] for y in range(200)])
dataout = np.array([[0 for x in range(8)] for y in range(200)])
latchvalues =  np.array([0 for x in range(8)])
fig, ax = plt.subplots()
fig2, ax2 = plt.subplots()
count = 1
dim1 = 31; dim2 = 12; dim3 = 8
ax.axis([0,200,0,100000])
ax2.axis([-2,dim1+1, -2, dim2+1])

plt.show(block=False)

loc = ("Calibration_S3.xlsx")
 
wb = xlrd.open_workbook(loc)
sheet = wb.sheet_by_index(0)


Calibration = np.zeros((dim1, dim2, dim3))
Calibration [0][0][0] = 1

for i in range (0,dim1):
	for j in range (0,dim2):
		for k in range (0,dim3):
			Calibration[i][j][k] = sheet.cell_value( i,j+dim2*k)


lines = [None]*8

for i in range(0,8):
	lines[i], = ax.plot(np.zeros(200))

# plotpoint, = ax2.plot(105,200,'ro') 

xlist = np.zeros(dim1*dim2);
ylist = np.zeros(dim1*dim2);

pointlist_x = np.zeros(dim3*(dim3-1))
pointlist_y = np.zeros(dim3*(dim3-1))



for i in range (0,dim2):
	for j in range (0,dim1):
		xlist[i*dim1 +j] = j
		ylist[i*dim1 +j] = i

CoG = [0,0]

scatterpoint = ax2.scatter(xlist,ylist, marker="s",s=900) 
linepoints = ax2.scatter(pointlist_x,pointlist_y)
center = ax2.plot(CoG[0],CoG[1],'ro')[0]


ax2.set_aspect('equal')


       
peakcounter = 0
state = 0

while(1):

	CoG = [0,0]
	count = count + 1;
	timenow = time.time()
	if (timenow > lasttime):
		hz = 1/(timenow - lasttime)

	lasttime = timenow
	# print(str(hz) + " Hz")

	while(ser.read() != b':'):
		pass

	ser.read()
	tdata = ser.read(81)

	charcounter = 0
	tempdata = []
	i = 0
	while(i < 71):
		try:
			data[charcounter] = float(bytes(tdata[i:i+11]).decode("utf-8"))
		except ValueError:
			pass
		
		charcounter = charcounter + 1
		i = i + 10

	dataarray = np.array(data.copy()).reshape((1,8))
	datamem = np.append(datamem, dataarray, axis=0)
	#print(np.size(datamem[:,0]))


	high = 0
	wide = 0

	if(len(datamem) > 200):
		datamem = np.delete(datamem,0, 0)

	if(len(dataout) > 199):
		dataout = np.delete(dataout,0, 0)


	# print(np.shape(np.append(dataout, dataarray - datamem[194,:].reshape((1,8)), axis=0)))
	dataoutpoint = dataarray.copy()
	if(state == 0):
		dataoutpoint = dataarray - datamem[196,:].reshape((1,8))
		dataout = np.append(dataout,dataoutpoint, axis=0)

	point  = [0,0]
	if(state == 1):
		dataoutpoint = dataarray - latchvalues.reshape((1,8))
		dataout = np.append(dataout, dataoutpoint, axis=0)

	peakness = 1
	i = 0


	# print(dataoutpoint[0])

	datapoint = dataoutpoint[0]
	ratios = np.zeros(8)
	matchs = np.zeros((dim1,dim2))
	averageMatch = 0
	bestmatch = 100000
	pos = [0,0]
	worstmatch = 0
	average = 0

	if 0 in dataoutpoint[0]:
		ratios = np.ones(8)
	else:
		for i in range (0,dim1):
			for j in range (0,dim2):
				average = 0
				for k in range (0,8):
					average = average + abs(datapoint[k]/8)
				for k in range (0,8):
					ratios[k] = datapoint[k] / average
				match = 0
				maxk = 0
				penk = 0
				for k in range (1,8):
					match = match + (abs(ratios[k] - Calibration[i][j][k]))
				matchs[i][j] = match
				if matchs[i][j] > worstmatch:
					worstmatch = matchs[i][j]
				if matchs[i][j] < bestmatch:
					bestmatch = matchs[i][j]
					pos = [i,j]

	for i in range (0,dim1):
		for j in range (0,dim2):
			matchs[i][j] = (matchs[i][j] - bestmatch)/(worstmatch - bestmatch)


	i = 0
	for line in lines:
		line.set_ydata(dataout[:,i])
		peakness = peakness * (abs((datamem[196,i]-datamem[195,i])) + abs((datamem[198,i]-datamem[199,i])))/100
		i = i + 1

	if (peakness > 10000):
		
		peakcounter = 5
		if(state == 0):
			for i in range(0,8):
				latchvalues[i] = datamem[196,i]
		state = 1



	ax.axis([0,200,min(-700,np.amin(dataout)-500),max(700, np.amax(dataout)+500)])
	
	colors = []
	points = [[-1/2,1/2],[-1/4,1/2],[1/4,1/2],[1/2,1/2],[1/2,-1/2],[1/4,-1/2],[-1/4,-1/2],[-1/2,-1/2 ]]

	for k in range (0,8):
		points[k][0] = (points[k][0]+1/2)*dim1
		points[k][1] = (points[k][1]+1/2)*dim2

	# print(points)

	leftshift = 0
	rightshift = 0
	upshift = 0
	downshift = 0

	xchords = []
	ychords = []
	dotcolors = []
	dotsizes = []

	total_mass = 0


	for j in range (0,dim3):
		for k in range (0,dim3):
			if(k != j):
				kfactor0 = 0;
				jfactor0 = 0;
				kfactor1 = 0;
				jfactor1 = 0;
				
				if(datapoint[k] > 0):
					kfactor0 = points[k][0]*datapoint[k]
					kfactor1 = points[k][1]*datapoint[k]
				else:
					kfactor0 = (dim1 - points[k][0])*abs(datapoint[k])
					kfactor1 = (dim1 - points[k][1])*abs(datapoint[k])
				
				if(datapoint[j] > 0):
					jfactor0 = points[j][0]*datapoint[j]
					jfactor1 = points[j][1]*datapoint[j]
				else:
					jfactor0 = (dim2 - points[j][0])*abs(datapoint[j])
					jfactor1 = (dim2 - points[j][1])*abs(datapoint[j])
				xchord = (kfactor0 + jfactor0)/(abs(datapoint[k]) + abs(datapoint[j]))
				ychord = (kfactor1 + jfactor1)/(abs(datapoint[k]) + abs(datapoint[j]))
				dotcolor = (0,max(0, min(1, (abs(datapoint[j]) + abs(datapoint[k]))/ (4*average))),0)
				dotsize = max(0,(datapoint[j] + datapoint[k])/np.sqrt(average))
				CoG[0] = CoG[0] + xchord * (abs(datapoint[k]) + abs(datapoint[j]))**2
				CoG[1] = CoG[1] + ychord * (abs(datapoint[k]) + abs(datapoint[j]))**2
				total_mass = total_mass +  (abs(datapoint[k]) + abs(datapoint[j]))**2



				xchords.append(xchord)
				ychords.append(ychord)
				dotcolors.append(dotcolor)
				dotsizes.append(dotsize)


	
	# print(xchords)
	# print(ychords)
	print(CoG)

	if(total_mass):
		CoG[0] = CoG[0] / total_mass
		CoG[1] = CoG[1] / total_mass



	if (state == 1):
		for i in range (0,dim2):
			for j in range (0,dim1):
				if(pos[1] == i and pos[0] == j):
					colors.append((1,1,1))				
				else:
					colors.append((matchs[j][i] ,0,1-matchs[j][i] ))
				# print(matchs[j][i])	
	else:
		for i in range (0,dim1):
			for j in range (0,dim2):
				colors.append((0,0,0))

				

                                                                                                                                               

	# scatterpoint.set_color(colors)
	linepoints.set_offsets(np.c_[xchords,ychords])
	linepoints.set_color(dotcolors)
	linepoints.set_sizes(dotsizes)
	center.set_xdata(CoG[0])
	center.set_ydata(CoG[1])

	print(CoG)


	fig.canvas.draw()
	fig.canvas.flush_events()
	# print(Calibration)

	ser.flushInput()

	fig2.canvas.draw()
	fig2.canvas.flush_events()



	# print(peakness)


	# if(count > 2000):
	# 	plt.show()

